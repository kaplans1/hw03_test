% Homework 3: Interface Design & Representation Design
%
% due **Wed.** 5/27 --- self-eval due **Fri.** 5/29
[modeline]: # vim: ft=markdown

# Part 1: Interfaces are Separate from Implementation

## Purpose

The goal of this assignment is to practice interface design. You will learn
that a well-designed interface is distinct from its implementations- meaning
that the user of an interface does not necessarily care about *how* something
is done (implementation) but *what* is done.

## Design Exercise: Adding Players

Last week, you implemented the
[`CoinGameModel`](hw03/src/cs3500/hw03/CoinGameModel.java) interface with
two different sets of rules. As designed, the interface says nothing
about players or turns---it merely tracks the state of the game from
move to move, and it's totally oblivious to *who* takes each turn.

Suppose, instead, that we wanted our coin game classes to keep track of
whose turn it is, to enforce the order of play, and to be able to tell
us who has won once the game is over. Additionally, we want to allow new
players to join the game at any time.

Players must be able to be uniquely identified by the client, and that
identification must be stable- that is, it will not change when new players are
added to the game.

For these exercises, you will consider how to modify the interface
design and the representation to support these new features. (You won’t
need to implement any methods.)

## Interface Design

The interface needs to be updated to support keeping track of players,
turns, and the winner. It should handle an arbitrary number of players,
it must allow new players to join at any time, and players’ identities
must be stable.

 1. Modify the [`CoinGameModel`](hw03/src/cs3500/hw03/CoinGameModel.java)
    interface to support the new features.

Be sure to list any assumptions you make, and don’t forget Javadoc.

**You need not implement this new interface.**

# Part 2: Representation and Invariants

## Purpose

The purpose of this part of the assignment is to practice representation
design. You will learn how to represent a specified functionality (your
interface) using fields and class invariants.

## Design the Representation
Once you have designed the interface, you can begin designing a concrete
representation for it. Designing the representation means deciding what
fields to use in order to implement the functionality specified by the
interface, while thinking carefully about how the data corresponds to
the information in the problem domain and about what invariants are
needed to rule out representations that don't map to the problem domain.

 2. In [`StrictCoinGameModel.java`](hw03/src/cs3500/hw03/StrictCoinGameModel.java),
    declare the fields needed to support the methods in the interface
    you’ve designed.

 3. Below the declaration of the fields, write an implementer comment
    describing, as precisely as you can, your representation’s class
    invariant(s).

**You need not implement any methods in this class.**

## Construction

Constructors and static factories are not part of the Java language’s
notion of `interface`{.java}, but they are still essential parts of the
public interface (in the non-java sense of the word) that a class or hierarchy
presents to its clients. Now that you know what your representation is and
what your invariants are,you can design how instances will be constructed.
You need not implement construction, however—we are just interested in the
interface for now.

 4. In [`StrictCoinGameModel.java`](hw03/src/cs3500/hw03/StrictCoinGameModel.java),
    describe your constructor API. This comprises the names of any
    public constructors and static factory methods that you desire^[You
    don’t need to get fancy.], along with the names and types of their
    parameters, and good Javadoc comments that document their usage,
    including any preconditions.

**You need not implement the bodies of any constructors or factories.**

## Testing

Even before you write a line of your concrete class’s implementation,
you should have a good idea how to test it. You’ve designed the
mechanisms for creating `StrictCoinGameModel` objects and the methods
for manipulating them, which means even though you haven’t implemented
it yet, you know how to create game instances and invoke methods on
them, and you know what results to expect. That means you can write
tests.

 5. In `StrictCoinGameModelTest.java`, write a comprehensive test suite
    for the new object construction and player functionality that you
    designed.

You don’t need to test any features from Problem Set 2, since you’ve
tested those already. Of course, you probably can’t get away with
avoiding them entirely; for example, to test the winner functionality,
you probably need to play some moves.

**You need not run these tests, because that would require implementing
the class under test.** Even though you cannot run them, writing tests
is a good way to make sure your interface makes sense and to demonstrate
that to the graders.

# Deliverables

 - `CoinGameModel.java`
 - `StrictCoinGameModel.java`
 - `StrictCoinGameModelTest.java`

# Grading Standards

For this assignment, you will be graded on:

 - the design of your `CoinGameModel` interface (primarily how well it
   supports the requisite functionality, though clarity and good style
   are important too),
 - the appropriateness of your representation choices for
   `StrictCoinGameModel`, and
 - the adequacy of its class invariants.

# Submission

Please submit your homework to the [CS 3500 submission
server](https://cs3500s15.ccs.neu.edu) by 11:59 PM on Wednesday,
May 27. Then be sure to complete your self evaluation by 11:59 PM on
Friday, May 29.
